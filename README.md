# enhance-scala
重新夯实一下scala。顺便把做的章节习题记录一下

每个章节的filename is chapterxx.scala

工作中spark写的比较多，索性再把快学scala看一遍

这里面比较重要的内容有：继承、特质、高阶函数、集合、模式匹配和样例类、类型参数。
这一部分内容是Scala十分重要的部分，学好这些才能熟练使用Scala

第一章 基础
要点：
- 使用Scala解释器
- 用var和val定义变量
- 数字类型
- 使用操作符和函数
- 浏览Scaladoc


第二章 控制结构和函数
要点：
- if表达式有值
- 块也有值-是它最后一个表达式的值
- Scala的for循环就像是"增强版""的Java for循环
- 分号（在绝大多数情况下）不是必需的
- void类型是Unit
- 避免在函数定义中使用return
- 注意别在函数式定义中漏掉了=
- 异常的工作方式和Java或C++中基本一样，不同的是你在catch语句中使用"模式匹配""
- Scala没有受检异常

第三章 数组相关操作
要点：
- 若长度固定则使用Array，若长度可能有变化则使用ArrayBuffer
- 提供初始值时不要使用new
- 用()来访问元素
- 用for(elem<-arr)来遍历元素
- 用for(elem<-arr if ...)... yield ... 来将原数组转型为新数组
- Scala数组和Java数组可以互操作；用ArrayBuffer，使用scala.collection.JavaConversions中的转换函数

第四章 映射和元组
要点：
- Scala有十分易用的语法来创建、查询和遍历映射
- 你需要从可变的和不可变的映射中做出选择
- 默认情况下，你得到的是一个哈希映射，不过你也可以致命要树形映射
- 你可以很容易地在Scala映射和Java映射之间来回切换
- 元组可以用来聚集值

第五章 类
要点：
- 类中的字段自动带有getter方法和setter方法
- 你可以用定制的getter/setter方法替换掉字段的定义，而不必修改使用类的客户端-这就是所谓的"统一访问原则"
- 用@BeanProperty注解来生成JavaBeans的getXxx/setXxx方法
- 每个类都有一个主要的构造器，这个构造器和类定义"交织"在一起。它的参数直接成为类的字段。主构造器执行类体中所有的语句
- 辅助构造器是可选的。它们叫做this

第六章 对象
要点：
- 用对象作为单例或存放工具方法
- 类可以拥有一个同名的伴生对象
- 对象可以扩展类或特质
- 对象的apply方法通常用来构造伴生类的新实例
- 如果不想显式定义main方法，可以用扩展App特质的对象
- 你可以用过扩展Enumeration对象来实现枚举

第七章 包和引入
要点：
- 包也可以像内部类那样嵌套
- 包路径不是绝对路径
- 包声明链x.y.z并不自动将中间包x和x.y变成可见
- 位于文件顶部不带花括号的包声明在整个文件范围内有效
- 包对象可以持有函数和变量
- 引入语句可以引入包、类和对象
- 引入语句可以出现在任何位置
- 引入语句可以重命名和隐藏特定成员
- java.lang、scala和Predef总是被引入

第八章 继承
要点：
- extends、final关键字和Java中相同
- 重写方法时必须用override
- 只有主构造器可以调用超类的主构造器
- 你可以重写字段

第九章 文件和正则表达式
要点：
- Source.fromFile(...).getLines.toArray输出文件的所有行
- Source.fromFile(...).mkString以字符串形式输出文件内容
- 将字符串转换为数字，可以用toInt或toDouble方法
- 使用Java的PrintWriter来写入文本文件
- "正则".r是一个Regex对象
- 如果你的正则表达式包含反斜杠或引号的话，用"""..."""
- 如果正则模式包含分组，你可以用如下语法来提取它们的内容for(regex(变量1,...,变量n)<-字符串)

第十章 特质
要点：
- 类可以实现任意数量的特质
- 特质可以要求实现它们的类具备特定的字段、方法或超类
- 和Java接口不同，Scala特质可以提供方法和字段的实现
- 当你将多个特质叠加在一起时，顺序很重要-其方法先被执行的特质排在更后面

第十一章 操作符
要点：
- 标识符由字母、数字或运算符构成
- 一元和二元操作符其实是方法调用
- 操作符优先级取决于第一个字符，而结合性取决于最后一个字符
- apply和update方法在对expr(args)表达式求值时被调用
- 提取器从输入中提取元组或值的序列

第十二章 高阶函数
要点：
- 在Scala中函数是"头等公民"，就和数字一样
- 你可以创建匿名函数，通常还会把它们交给其他函数
- 函数参数可以给出需要稍后执行的行为
- 许多集合方法都接受函数参数，将函数应用到集合中的值
- 有很多语法的简写让你以简短且易读的方法表达函数参数
- 你可以创建操作代码块的函数，它们看上去就是内建的控制语句

第十三章 集合
要点：
- 所有集合都扩展自Iterable特质
- 集合有三大类，分别为序列、集和映射
- 对于几乎所有集合类，Scala都同时提供了可变和不可变的版本
- Scala列表要么是空的，要么拥有一头一尾，其中尾部本身又是一个列表
- 集是无先后次序的集合
- 用LinkedHashSet来保留插入顺序，或者用SortedSet来按顺序进行迭代
- +将元素添加到无先后次序的集合中；+:和:+向前或向后追加到序列；++将两个集合串接在一起；-和--移除元素
- Iterable和Seq特质有数十个用于常见操作的方法。在编写冗长繁琐的循环之前，先看看这些方法能够满足你的需要
- 映射、折叠和拉链操作是很有用的技巧，用来将函数或操作应用到集合中的元素

第十四章 模式匹配和样例类
要点：
- match表达式是一个更好switch，不会有意外掉入到下一个分支的问题
- 如果没有模式匹配，会抛出MatchError。可以用case _模式来避免
- 模式可以包含一个随意定义的条件，称作守卫
- 你可以对表达的类型进行匹配；优先选择模式匹配而不是isInstanceOf/asInstanceOf。
- 你可以匹配数组、元组和样例类的模式，然后将匹配到的不同部分绑定到变量
- 在for表达式中，不能匹配的情况会被安静地跳过
- 样例类是编译器会为之自动产出模式匹配所需要的方法的类
- 样例类继承层级中的公共超类应该是sealed的
- 用Option来存放对于可能存在也可能不存在的值-这比null更安全

第十七章 类型参数
要点：
- 类、特质、方法和函数都可以有类型参数
- 将类型参数放置在名称之后，以方括号括起来
- 类型界定的语法为T<: UpperBound、T>:LowerBound、T<%ViewBound、T:ContextBound
- 你可以用类型约束来约束一个方法，比如(implicit ev:T<:<UpperBound)
- 用+T(协变)来表示某个泛型类的子类型关系和参数T方向一致，或用-T(逆变)来表示方向相反
- 协变适用于表示输出的类型参数，比如不可变集合中的元素
- 逆变适用于表示输入的类型参数，比如函数参数